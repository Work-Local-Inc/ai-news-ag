import os
import json
import requests
from datetime import datetime
from typing import List, Dict
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError

class SlackNotifier:
    """Handle Slack notifications for daily news updates"""
    
    def __init__(self):
        self.webhook_url = os.getenv('SLACK_WEBHOOK_URL')
        self.bot_token = os.getenv('SLACK_BOT_TOKEN')
        self.channel = os.getenv('SLACK_CHANNEL', '#ai-news')
        
        if self.bot_token:
            self.client = WebClient(token=self.bot_token)
        else:
            self.client = None
    
    def format_article_block(self, article: Dict) -> Dict:
        """Format a single article as a Slack block"""
        title = article.get('title', 'No Title')[:100]
        description = article.get('description', '')[:200]
        url = article.get('url', '')
        source = article.get('source', 'Unknown')
        score = article.get('score', 0)
        published = article.get('published', '')[:10]
        
        # Create source badge
        source_emoji = "🟢" if source == "Hacker News" else "🔵"
        score_text = f" • {score} pts" if score > 0 else ""
        
        block = {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*<{url}|{title}>*\n{description}\n{source_emoji} *{source}*{score_text} • 📅 {published}"
            }
        }
        
        # Add image if available
        if article.get('image_url'):
            block["accessory"] = {
                "type": "image",
                "image_url": article['image_url'],
                "alt_text": title
            }
        
        return block
    
    def create_daily_message(self, articles: List[Dict], summary_stats: Dict = None) -> Dict:
        """Create the complete daily news message"""
        today = datetime.now().strftime("%B %d, %Y")
        
        # Header block
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"🤖 AI News Daily - {today}"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"Good morning! Here are today's top {len(articles)} AI news stories:"
                }
            }
        ]
        
        # Add summary stats if provided
        if summary_stats:
            stats_text = []
            if summary_stats.get('hacker_news_count', 0) > 0:
                stats_text.append(f"🟢 {summary_stats['hacker_news_count']} from Hacker News")
            if summary_stats.get('news_api_count', 0) > 0:
                stats_text.append(f"🔵 {summary_stats['news_api_count']} from News Sources")
            
            if stats_text:
                blocks.append({
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": " • ".join(stats_text)
                        }
                    ]
                })
        
        blocks.append({"type": "divider"})
        
        # Add article blocks
        for i, article in enumerate(articles[:10]):  # Limit to 10 articles for Slack
            blocks.append(self.format_article_block(article))
            
            # Add divider between articles (except last)
            if i < len(articles[:10]) - 1:
                blocks.append({"type": "divider"})
        
        # Footer
        blocks.extend([
            {"type": "divider"},
            {
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": "🔗 View full news dashboard • Generated by AI News Scraper"
                    }
                ]
            }
        ])
        
        return {"blocks": blocks}
    
    def send_webhook_message(self, message: Dict) -> bool:
        """Send message via webhook"""
        if not self.webhook_url:
            print("❌ No Slack webhook URL configured")
            return False
        
        try:
            response = requests.post(
                self.webhook_url,
                json=message,
                headers={'Content-Type': 'application/json'}
            )
            response.raise_for_status()
            print("✅ Slack message sent successfully via webhook")
            return True
        except Exception as e:
            print(f"❌ Error sending Slack webhook: {e}")
            return False
    
    def send_bot_message(self, message: Dict) -> bool:
        """Send message via Slack Bot API"""
        if not self.client:
            print("❌ No Slack bot token configured")
            return False
        
        try:
            result = self.client.chat_postMessage(
                channel=self.channel,
                **message
            )
            print("✅ Slack message sent successfully via bot")
            return True
        except SlackApiError as e:
            print(f"❌ Error sending Slack message: {e.response['error']}")
            return False
    
    def send_daily_news(self, articles: List[Dict], summary_stats: Dict = None) -> bool:
        """Send the daily news update to Slack"""
        message = self.create_daily_message(articles, summary_stats)
        
        # Try bot API first, fallback to webhook
        if self.send_bot_message(message):
            return True
        elif self.send_webhook_message(message):
            return True
        else:
            print("❌ Failed to send message via both bot and webhook")
            return False
    
    def test_connection(self) -> bool:
        """Test Slack connection"""
        test_message = {
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": "🧪 Test message from AI News Scraper - connection successful!"
                    }
                }
            ]
        }
        
        return self.send_webhook_message(test_message) or self.send_bot_message(test_message) 